{"mappings":"AAAA,gCAAgC,CAAC;IAC/B;;QAEI;IACJ,OAAO,EAAE,IAAI,CAAC;IACd;;QAEI;IACJ,MAAM,EAAE,GAAG,CAAC;CACb,GAAG;IACF;;QAEI;IACJ,OAAO,EAAE,KAAK,CAAC;IACf;;QAEI;IACJ,KAAK,EAAE,GAAG,CAAC;CACZ,CAAC,GAAG;IACH;;QAEI;IACJ,KAAK,EAAE,IAAI,CAAC;IACZ;;QAEI;IACJ,EAAE,EAAE,MAAM,CAAC;CACZ,CAAA;AAED;;;;;;GAMG;AACH,qBAAa,OAAO;IAMlB,OAAO,KAAK,SAAS,GAEpB;IAED,SAAS,CAAC,cAAc,EAAE;QAAE,GAAG,EAAE,IAAI,CAAC;QAAC,IAAI,EAAE,MAAM,CAAC;QAAC,EAAE,EAAE,MAAM,CAAC;QAAC,SAAS,EAAE,MAAM,CAAC;KAAE,EAAE,CAAM;IAC7F,SAAS,CAAC,YAAY;IAYtB,SAAgB,OAAO;;mBAIV,MAAM;QAGjB,4GAA4G;mBACjG,MAAM;QASjB,6JAA6J;0BAC3I,MAAM,EAAE;MAW1B;IAEF,yBAAyB;IAClB,OAAO,SAAQ;IAEtB,yBAAyB;IACzB,SAAgB,UAAU;mBACb,MAAM;;;;QAMjB,2GAA2G;mBAChG,MAAM,SAAS,MAAM,GAAG,OAAO,KAAG,IAAI;MAGjD;IAEF;;;OAGG;;IAcH;;;;OAIG;IACI,cAAc,CAAC,OAAO,EAAE,MAAM,GAAG,IAAI;IAO5C;;;OAGG;IACI,GAAG,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAC,iBAAiB,CAAC;IAmCxD;;OAEG;IACU,QAAQ,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAC;QAAE,OAAO,EAAE,IAAI,CAAC;QAAC,MAAM,EAAE,GAAG,CAAA;KAAE,GAAG;QAAE,OAAO,EAAE,KAAK,CAAC;QAAC,KAAK,EAAE,GAAG,CAAA;KAAE,CAAC;IAIjH;;OAEG;IACU,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC;IA+DlC;;OAEG;IACI,IAAI;CASZ;AAED,eAAe,OAAO,CAAC","sources":["src/src/lib.ts","src/lib.ts"],"sourcesContent":[null,"export type ExecutionResponse = ({\n  /**\n    * Indicates a successful response from the sandbox\n    */\n  success: true;\n  /**\n    * The result of the execution\n    */\n  result: any;\n} | {\n  /**\n    * Indicates an unsuccessful response from the sandbox\n    */\n  success: false;\n  /**\n    * The error of the execution\n    */\n  error: any;\n}) & {\n  /**\n    * @internal Indicates a response from the sandbox\n    */\n  sbxRs: true;\n  /**\n    * @internal The id of the request\n    */\n  id: string;\n}\n\n/**\n * @example ```ts\n * const sandbox = new Sandbox();\n * sandbox.overwriteHost('https://new-host.com');\n * sandbox.evaluate('console.log(\"Hello, world!\");');\n * ```\n */\nexport class Sandbox {\n  private host: string | null = null;\n  private frames: HTMLIFrameElement[] = [];\n  private contentWindow: Window | null = null;\n  private listenersById: Record<string, (data: any) => void> = {};\n  private __sandboxId = Math.random().toString(36).substring(7);\n  private get sandboxId(): string {\n    return this.__sandboxId;\n  }\n  private params: Record<string, string | boolean> = {};\n  protected executionQueue: { sbx: true; code: string; id: string, sandboxId: string, }[] = [];\n  protected executeQueue() {\n    if (!this.contentWindow) return false;\n    while (this.executionQueue.length > 0) {\n      const data = this.executionQueue.shift();\n      if (this.host === 'http://localhost:5173')\n        console.log('[sbjs] executing', data);\n      this.contentWindow?.postMessage(data, '*');\n    };\n    return true;\n  }\n\n  private _sandboxParams = [] as string[];\n  public readonly sandbox = {\n    getAll: () => {\n      return [...this._sandboxParams];\n    },\n    get: (key: string) => {\n      return this._sandboxParams.includes(key);\n    },\n    /** Needs to be called prior to init() - to modify parameters, call kill(), call this, then init() again. */\n    add: (key: string) => {\n      this._sandboxParams.push(key);\n\n      this.frames.forEach((frame) =>\n        frame.sandbox.add(key)\n      );\n\n      this.parameters.set('sandbox', this._sandboxParams.join('+'));\n    },\n    /** You should reset the sandbox after this, however as the root sandbox is directly affected, the nested one should be fine without needing you to reset. */\n    remove: (...keys: string[]) => {\n      keys.forEach(key => {\n        this._sandboxParams.splice(this._sandboxParams.indexOf(key), 1)\n\n        this.frames.forEach((frame) =>\n          frame.sandbox.remove(key)\n        );\n      });\n\n      this.parameters.set('sandbox', this._sandboxParams.join('+'));\n    },\n  };\n\n  /** Frame load timeout */\n  public timeout = 8192;\n\n  /** Sandbox parameters */\n  public readonly parameters = {\n    get: (key: string) => {\n      return this.params[key] ?? null;\n    },\n    getAll: () => {\n      return { ...this.params };\n    },\n    /** Needs to be called prior to init() - to modify parameters, call kill(), call this, then init() again */\n    set: (key: string, value: string | boolean): void => {\n      this.params[key] = value;\n    },\n  };\n\n  /**\n   * Creates a new Sandbox instance\n   * @param host The host to use for the sandbox\n   */\n  constructor() {\n    this.parameters.set('sbxid', this.sandboxId);\n    this.parameters.set('proxy', true);\n    [\n      'allow-scripts',\n      'allow-same-origin',\n      'allow-popups',\n      'allow-forms',\n      'allow-downloads',\n      'allow-modals',\n    ].forEach((k) => this.sandbox.add(k));\n  }\n\n  /**\n   * Overwrites the host of the sandbox\n   * @param newHost The new host to use\n   * @internal\n   */\n  public _overwriteHost(newHost: string): void {\n    this.host = newHost;\n    this.frames.forEach((frame) => {\n      frame.src = `${this.host ?? 'https://sandboxjs.foo'}/?${Object.entries(this.params).map(([key, value]) => `${key}=${value}`).join('&')}`;\n    });\n  }\n\n  /**\n   * Runs a function in the sandbox\n   * @param funcBody The function to run\n   */\n  public run(funcBody: string): Promise<ExecutionResponse> {\n    return new Promise<ExecutionResponse>((resolve, reject) => {\n      const id = 'sbjs_eval_' + Math.random().toString(36).substring(7);\n      const obj = {\n        sbx: true as true,\n        code: funcBody,\n        id,\n        sandboxId: this.sandboxId,\n      };\n      this.listenersById[id] = (a: ExecutionResponse) => {\n        if (this.host === 'http://localhost:5173')\n          this.listenersById[id] = (data) => {\n            console.warn('[sbjs] duplicate listener call', {\n              id,\n              data,\n              err: new Error('Duplicate listener call'),\n            });\n            resolve(data);\n          };\n        resolve(a);\n      };\n      this.contentWindow = this.contentWindow ?? this.frames[0]?.contentWindow;\n      this.executionQueue.push(obj);\n      if (this.contentWindow === null || this.contentWindow === undefined || this.contentWindow.closed === true) {\n        (async () => {\n          await new Promise((res) => setTimeout(res, this.timeout));\n          if (this.executionQueue.includes(obj)) {\n            this.executionQueue.splice(this.executionQueue.indexOf(obj), 1);\n            reject('Frame load timed out');\n          };\n        })();\n      } else this.executeQueue();\n    });\n  }\n\n  /**\n   * Alias to {@link Sandbox.run}\n   */\n  public async evaluate(funcBody: string): Promise<{ success: true; result: any } | { success: false; error: any }> {\n    return this.run(funcBody);\n  }\n\n  /**\n   * Initializes the sandbox\n   */\n  public async init(): Promise<this> {\n    const frame = document.createElement('iframe');\n    this.sandbox.getAll().forEach(k => frame.sandbox.add(k));\n    frame.src = `${this.host ?? 'https://sandboxjs.foo'}/?proxy&${Object.entries(this.params).map(([key, value]) => `${key}=${value}`).join('&')}`;\n    this.frames.push(frame);\n    this.contentWindow = frame.contentWindow;\n\n    const listener = async (e: MessageEvent) => {\n      if (e.data && e.data.sbjs_ready) {\n        this.contentWindow = frame.contentWindow;\n        window.addEventListener('message', listener);\n      } else if (e.data && e.data.sbxRs) {\n        // sandbox response\n        const data = e.data;\n        if (this.host === 'http://localhost:5173') {\n          if (data.success) {\n            console.log('[sbjs] success', data.result);\n          } else {\n            console.error('[sbjs] error', data.error);\n          }\n        }\n        if (typeof data.id !== 'string') {\n          return console.error('[sbjs] data.id is not a string');\n        }\n        if (typeof this.listenersById[data.id] !== 'function') {\n          console.warn(new Error(`[sbjs] listener is not a function (id: ${data.id})`))\n          return;\n        }\n        this.listenersById[data.id](data);\n      }\n    };\n\n    frame.style.display = 'block';\n    frame.style.width = '0';\n    frame.style.height = '0';\n    frame.style.border = 'none';\n    frame.style.position = 'fixed';\n    frame.style.top = '-10000vh';\n    frame.style.left = '-10000vw';\n\n    window.addEventListener('message', listener);\n\n    // resolve on frame load, reject on frame error or timeout\n    const promise = new Promise<void>((resolve, reject) => {\n      frame.addEventListener('load', () => {\n        resolve();\n      });\n      frame.addEventListener('error', (e) => {\n        reject(e);\n      });\n      setTimeout(() => {\n        reject('Frame load timed out');\n      }, this.timeout);\n    });\n\n    (document.body ?? document.head).appendChild(frame);\n\n    await promise;\n    this.executeQueue();\n\n    return this;\n  };\n\n  /**\n   * Removes the sandbox\n   */\n  public kill() {\n    this.frames.forEach((frame) => {\n      frame.remove();\n    });\n    this.frames = [];\n    this.contentWindow = null;\n    this.executionQueue = [];\n    this.listenersById = {};\n  };\n}\n\nexport default Sandbox;\n\n// @ts-ignore\nif (typeof window !== 'undefined') window.SandboxJS = Sandbox;\n"],"names":[],"version":3,"file":"lib.d.ts.map"}